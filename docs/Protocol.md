# VSCP Documentation
This is an unofficial documentation of the Virtual Society Server-Client Protocol (VSCP). Most of the content written here are hypotheses from manual packet decoding, therefore it might not be accurate. The interpretations provided here should be considered entirely subjective.

Currently, it is also incomplete as some parts of the protocol lack any viable explaination. If you feel like something could use a better interpretation or you have a hypothesis on how something works, feel free to make a suggestion or a PR.

# Overview
The protocol follows a client-server model and uses TCP for sending data between the server and its clients.

The data that it sends is sometimes a mix of binary and "human readable" data, therefore thoughout this documentation, both hexadecimal and string representations are provided where applicable. The strings might include C-like escape sequences.

# Glossary
## Packet layout
A packet layout is described using a table, split into sections (rows) that follows one another in the exact order of the actual packet itself.

Example:

| Section | Size | Type |
| --- | --- | --- |
| Number of cats | 4 | uint32 |
| Number of dogs | 2 | uint16 |
| Some data | 12 | data |
| Some text | ~ | string |

All of the section sizes provided here are in bytes. Sections with `~` as the size have a varying size.

## Types
- `data`: Raw (arbitrary) data
- `int8`, `int16`, `int32`: n-bit signed integer
- `uint8`, `uint16`, `uint32`: n-bit unsigned integer
- `string`: Null-terminated string. Does not have a determined size.

All integer types are in little-endian byte order.

## Aura
Throughout the documentation, you'll find mentions of a user's "aura". This is used to refer to the Aura system used by the server.

In a nutshell: Each user will have a defined radius where they can be seen; that is their aura. If a user's aura overlaps another user's, then they can "see" each other. It is a bit more involved than this though, as their orientation also matters.

(See "A Spatial Model of Interaction in Large Virtual Environments" by Steve Benford & Lennart Fahl√©n for more details, in ECSCW '93, page 109-124)

The Aura system has influence on what data the client will accept from other users. If a client was sent any message that makes use of the broadcast ID (which also identifies their Aura) from another user that can't be "seen" by it, it will actively ignore the message. The server should also not send any message that are not within their aura.

# The `hello` Packet
To establish a connection to the server, the client first performs a TCP 3-way handshake with the server. If that succeeds, it sends the `hello` packet to the server:

| Hex | String |
| --- | --- |
| `0x68 0x65 0x6c 0x6c 0x6f 0x01 0x01` | hello\x01\x01 |

The server then replies with a matching `hello` packet, followed by the connection ID:

| Section | Size | Type |
| --- | --- | --- |
| Header | 13 | data |
| Connection ID | 1 | uint8 |

The header data is as follows:

| Hex | String |
| --- | --- |
| `0x68 0x65 0x6c 0x6c 0x6f 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00` | hello\0\0\0\0\0\0\0\0 |

The connection ID is generated by the server and could be used to uniquely identify clients. The original server software supposedly generated this ID by simply incrementing a counter and using the value until it hits 255, then go back to 0.

After receiving the `hello` packet from the server, the client should immediately follow up with a message packet containing a [`CMSG_NEW_USER`](#cmsg_new_user) section.

# Message Packets
After sending the `hello` packet, the client and the server can now talk to each other through structured message packets. A packet may contain multiple message sections placed one after another.

A section will always start with the following data:

| Section | Size | Type |
| --- | --- | --- |
| Section type | 4 | uint32 |

The section type defines how the message section should be interpreted.

Section sizes varies between different section types:

- For General Message sections: 17 + n bytes (let n be the content size, see below)
- For Position Update sections: 27 bytes

# General Message
| Section | Size | Type |
| --- | --- | --- |
| Section type | 4 | uint32 |
| ID 1 | 4 | uint32 |
| ID 2 | 4 | uint32 |
| Opcode | 4 | uint32 |
| Content size (n) | 1 | uint8 |
| Content | n | data |

- Section type = 0

ID 1 and 2's values are set depending on the type of opcode used and does not necessarily correlate to the current client's IDs.

For client messages: ID 1 is usually set to the connection ID, while ID 2 is usually set to the client ID (see [`SMSG_CLIENT_ID`](#smsg_client_id))

For server messages: ID values varies between each message type and content, check each of them for more details.

It is not important to distinguish between ID 1 and ID 2 (or between the connection ID and the client ID) as long as the server has enough information to identify a client and set unique IDs for each message.

The opcode describes how the content should be interpreted by the receiver.

- Known opcodes:
```
    CMSG_NEW_USER     = 0,
    SMSG_CLIENT_ID    = 1,
    SMSG_USER_JOINED  = 2,
    SMSG_USER_LEFT    = 3,
    SMSG_BROADCAST_ID = 4,
    MSG_COMMON        = 6,
    CMSG_STATE_CHANGE = 7,
    SMSG_UNNAMED_1    = 8,
    SMSG_USER_COUNT   = 11
```
Opcodes prefixed with MSG are used by both the client and the server, while CMSG and SMSG are used exclusively by the client and the server respectively. `UNNAMED` opcodes are opcodes that have no exact meaning bound to them (yet)

The following subsections describe the data expected in the content section of the message, depending on the opcode:

## CMSG_NEW_USER
The first thing that the client sends after receiving the server's `hello` reply is the `CMSG_NEW_USER` message, which identifies the user.

| Section | Size | Type |
| --- | --- | --- |
| Username | ~ | string |
| Avatar path | ~ | string |

The avatar path is a relative path based on where the avatar is located in the `world` folder of the Community Place Browser. Example: `avtwrl/01cat.wrl`

After receiving the `CMSG_NEW_USER` message, the server will proceed to broadcast [`SMSG_USER_JOINED`](#smsg_user_joined) to all clients connected to it (including the current client). The server will also send [`SMSG_CLIENT_ID`](#smsg_client_id), [`SMSG_UNNAMED_1`](#smsg_unnamed_1), [`SMSG_USER_JOINED`](#smsg_user_joined) and [`SMSG_BROADCAST_ID`](#smsg_broadcast_id) messages back to the client.

## SMSG_CLIENT_ID
Used to send the client ID. It can be identical to the connection ID.

| Section | Size | Type |
| --- | --- | ---|
| Unknown | 3 | data |
| Client ID | 1 | uint8 |

The unknown bytes are always set to zeroes.

In the original server software, the client ID (which is generated after [`CMSG_NEW_USER`](#cmsg_new_user) was sent) might differ from the connection ID (which is generated when the socket was first opened). However, it is fine to use the same ID for both.

## SMSG_USER_JOINED
Used to announce that someone has joined a user's aura.

| Section | Size | Type |
| --- | --- | --- |
| ID 1 Type | 2 | uint16 |
| Broadcast ID 1 | 2 | uint16 |
| ID 2 Type | 2 | uint16 |
| Broadcast ID 2 | 2 | uint16 |
| Avatar path | ~ | string |
| Username | ~ | string |

Broadcast ID 1 is always set to the broadcast ID of the user that joined the Aura. It is unknown what the second broadcast ID is used for, as it differs between users to users, although setting it to the same ID will work just fine. Both broadcast ID types must be set to 0.

## SMSG_USER_LEFT
Used to announce that someone has left a user's aura. This is also sent to other users within their aura when a user leaves the server.

| Section | Size | Type |
| --- | --- | --- |
| ID type | 2 | uint16 |
| Broadcast ID | 2 | uint16 |

## SMSG_BROADCAST_ID
Used to send the client's broadcast ID, which will be used for messages that are bound to a specific user (position updates, chat, state changes, etc.)

| Section | Size | Type |
| --- | --- | --- |
| ID type | 2 | uint16 |
| Broadcast ID | 2 | uint16 |

Type must always be 0. `0xFFFF` is a reserved type. The broadcast ID seems to be a randomly generated value from 1 to `0xFFFF` (0 is reserved for "no broadcast ID"). Could also be used to uniquely identify a client.

## MSG_COMMON
As the name implies, this is the most common opcode and is used for a number of things.

| Section | Size | Type |
| --- | --- | --- |
| ID type | 2 | uint16 |
| Broadcast ID | 2 | uint16 |
| Type | 4 | uint32 |
| Subtype | 1 | uint8 |
| Content | ~ | data |

The type defines what the content contains. Known types:
```
    REQUEST         = 0x10270000,
    CHAT_SEND       = 0x09000000,
    NAME_CHANGE     = 0x0D000000,
    AVATAR_CHANGE   = 0x0E000000,
    ROTATION_UPDATE = 0x02000000,
    SLEEP_UPDATE    = 0x0C000000
```

Possible subtype values are 0, 1, 2 and 3. They define what to do with the message.

- If subtype is 0 or 1, the message should be broadcasted to other clients.
- If subtype is 2 or 3, the message should be sent back to the client only.

Each type has a specific subtype. Note that when broadcasting messages to other clients, ID 1 and ID 2 must be set to those of the client being sent to.

The following subsections describe the content data of each type:

### REQUEST
- Subtype = 2

| Section | Size | Type |
| --- | --- | --- |
| Unknown | 1 | uint8 |
| Request name | ~ | string |
| Argument | ~ | string |
| ID type | 2 | uint16 |
| Broadcast ID | 2 | uint16 |

Since this message is not meant to be directed to other clients, the ID type must be set to `0xFFFF` and broadcast ID must be set to `0xF1D8`. Therefore, this type of message could also be sent by the client without having a broadcast ID.

Known "request names": startAreaRequest, broadcastRequest, yourStartArea, phaseState and syncDynamicModule

It is unknown what this message is for. One hypothesis is that this seems to be a part of the Simple Shared Script system. Nevertheless, the server doesn't really have to do anything with it (except sending it back to the client according to the subtype).

### CHAT_SEND
- Subtype = 0

Used to send chat messages.

| Section | Size | Type |
| --- | --- | --- |
| Message | ~ | string |

### NAME_CHANGE
- Subtype = 1

Used to announce a name change.

| Section | Size | Type |
| --- | --- | --- |
| New name | ~ | string |

### AVATAR_CHANGE
- Subtype = 1

Used to announce an avatar change.

| Section | Size | Type |
| --- | --- | --- |
| New avatar | ~ | string |

### ROTATION_UPDATE
- Subtype = 1

Used to update the character's rotation.

| Section | Size | Type |
| --- | --- | --- |
| Unknown | 48 | data |

It is not known how the rotation data should be interpreted. If we were to assume that all of the values are 4 bytes floats, then there would be 12 float values, or a 4x3 matrix.

### SLEEP_UPDATE
- Subtype = 1

Used to update the player's sleep state. This is a companion to `CMSG_STATE_CHANGE`, since it can't actually broadcast the user's state to other players.

| Section | Size | Type |
| --- | --- | --- |
| Sleep state | ~ | string |

It is not known how the sleep state should be interpreted. It looks something like this: `sleep:0 1:000000000000:26:0:`

Nevertheless, it is not important to know what it actually means.

## CMSG_STATE_CHANGE
Used to announce a player state change.

| Section | Size | Type |
| --- | --- | --- |
| State | 1 | uint8 |

Known state values:
- `0x03`: Leaving
- `0x04`: Active
- `0x05`: Sleep

Active and Sleep can be activated manually by the user. The Leaving state is triggered when the Browser is closing itself and will terminate the connection shortly.

If the state is Active or Sleep, the client will follow up with another packet containing a [`MSG_COMMON`](#msg_common) section to [send the Sleep State](#sleep_update).

## SMSG_UNNAMED_1
Unknown purpose.

| Section | Size | Type |
| --- | --- | --- |
| Value | 1 | uint8 |

Value is always set to 1.

## SMSG_USER_COUNT
Used to announce the number of users in the server.

| Section | Size | Type |
| --- | --- | --- |
| Unknown | 4 | uint32 |
| User count | 1 | uint8 |

The unknown value is always set to 1.

# Position Update
Used to update the character's position.

| Section | Size | Type |
| --- | --- | --- |
| Section type | 4 | uint32 |
| ID 1 | 4 | uint32 |
| ID 2 | 1 | uint8 |
| ID type | 2 | uint16 |
| Broadcast ID | 2 | uint16 |
| X | 4 | unknown |
| Y | 4 | unknown |
| Z | 4 | unknown |

- Section type = 2

ID 1 and ID 2 are always set to the connection ID and the client ID of the user, repectively. ID type must always be 0.

The server should broadcast this message to other users that are within the aura of the current user. ID 1 and ID 2 of the broadcasted message must be set to those of the user being sent to.

The server can also send a Position Update message to update a client's own character position.

It is not known how the coordinates should be interpreted. The first two bits of the value seems to be used as signbits, with `0xFF` for negative, `0x00` for positive. The other 3 bytes varies wildly depending on the position.

# Limitations
By design, the protocol is limited to 256 concurrent users. This is because, the `hello` packet that the server sends only uses an uint8 to send the connection ID; effectively limiting its range from 0 to 255, thus limiting it to 256 possible values. However, it is still entirely possible for a server to handle more than that, as TCP doesn't limit the amount of active connections, though it is impractical to do so. This is where WSL comes into use.

# License
This documentation is licensed under [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0)